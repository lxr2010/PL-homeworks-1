// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var Belt_List = require("rescript/lib/js/belt_List.js");

function toString(inst) {
  if (typeof inst !== "number") {
    if (inst.TAG === /* Cst */0) {
      return "Cst(" + inst._0.toString() + ")";
    } else {
      return "Var(" + inst._0.toString() + ")";
    }
  }
  switch (inst) {
    case /* Add */0 :
        return "Add";
    case /* Mul */1 :
        return "Mul";
    case /* Pop */2 :
        return "Pop";
    case /* Swap */3 :
        return "Swap";
    
  }
}

function listToString(instrs) {
  var listTailToString = function (instrs) {
    return List.fold_left((function (str, inst) {
                  return str + ";" + toString(inst);
                }), "", instrs);
  };
  if (!instrs) {
    return "[]";
  }
  var rest = instrs.tl;
  var inst = instrs.hd;
  if (rest) {
    return "[" + toString(inst) + listTailToString(rest) + "]";
  } else {
    return "[" + toString(inst) + "]";
  }
}

function $$eval(_instrs, _stk) {
  while(true) {
    var stk = _stk;
    var instrs = _instrs;
    if (!instrs) {
      return [
              /* [] */0,
              stk
            ];
    }
    var i = instrs.hd;
    if (typeof i === "number") {
      switch (i) {
        case /* Add */0 :
            if (stk) {
              var match = stk.tl;
              if (match) {
                _stk = {
                  hd: stk.hd + match.hd | 0,
                  tl: match.tl
                };
                _instrs = instrs.tl;
                continue ;
              }
              
            }
            break;
        case /* Mul */1 :
            if (stk) {
              var match$1 = stk.tl;
              if (match$1) {
                _stk = {
                  hd: Math.imul(stk.hd, match$1.hd),
                  tl: match$1.tl
                };
                _instrs = instrs.tl;
                continue ;
              }
              
            }
            break;
        case /* Pop */2 :
            if (stk) {
              _stk = stk.tl;
              _instrs = instrs.tl;
              continue ;
            }
            break;
        case /* Swap */3 :
            if (stk) {
              var match$2 = stk.tl;
              if (match$2) {
                _stk = {
                  hd: match$2.hd,
                  tl: {
                    hd: stk.hd,
                    tl: match$2.tl
                  }
                };
                _instrs = instrs.tl;
                continue ;
              }
              
            }
            break;
        
      }
    } else {
      if (i.TAG === /* Cst */0) {
        _stk = {
          hd: i._0,
          tl: stk
        };
        _instrs = instrs.tl;
        continue ;
      }
      var v = Belt_List.get(stk, i._0);
      if (v !== undefined) {
        _stk = {
          hd: v,
          tl: stk
        };
        _instrs = instrs.tl;
        continue ;
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Demo.res",
              32,
              16
            ],
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Demo.res",
            37,
            11
          ],
          Error: new Error()
        };
  };
}

function interpret(instrs) {
  var match = $$eval(instrs, /* [] */0);
  var match$1 = match[1];
  if (match$1) {
    return match$1.hd;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Demo.res",
          43,
          11
        ],
        Error: new Error()
      };
}

var StackMachineWithVariables = {
  toString: toString,
  listToString: listToString,
  $$eval: $$eval,
  interpret: interpret
};

function toString$1(expr) {
  switch (expr.TAG | 0) {
    case /* Cst */0 :
        return "Cst(" + expr._0.toString() + ")";
    case /* Add */1 :
        return "Add(" + toString$1(expr._0) + "," + toString$1(expr._1) + ")";
    case /* Mul */2 :
        return "Mul(" + toString$1(expr._0) + "," + toString$1(expr._1) + ")";
    case /* Var */3 :
        return "Var(" + expr._0.toString() + ")";
    case /* Let */4 :
        return "Let(" + toString$1(expr._0) + "," + toString$1(expr._1) + ")";
    
  }
}

var Nameless = {
  toString: toString$1
};

function comp(expr) {
  switch (expr.TAG | 0) {
    case /* Cst */0 :
        return {
                hd: {
                  TAG: /* Cst */0,
                  _0: expr._0
                },
                tl: /* [] */0
              };
    case /* Add */1 :
        return Belt_List.concatMany([
                    comp(expr._0),
                    comp(expr._1),
                    {
                      hd: /* Add */0,
                      tl: /* [] */0
                    }
                  ]);
    case /* Mul */2 :
        return Belt_List.concatMany([
                    comp(expr._0),
                    comp(expr._1),
                    {
                      hd: /* Mul */1,
                      tl: /* [] */0
                    }
                  ]);
    case /* Var */3 :
        return {
                hd: {
                  TAG: /* Var */1,
                  _0: expr._0
                },
                tl: /* [] */0
              };
    case /* Let */4 :
        return Belt_List.concatMany([
                    comp(expr._0),
                    comp(expr._1),
                    {
                      hd: /* Swap */3,
                      tl: {
                        hd: /* Pop */2,
                        tl: /* [] */0
                      }
                    }
                  ]);
    
  }
}

var NamelessExprToStackMachineWithVariables = {
  comp: comp
};

function toString$2(expr) {
  switch (expr.TAG | 0) {
    case /* Cst */0 :
        return "Cst(" + expr._0.toString() + ")";
    case /* Add */1 :
        return "Add(" + toString$2(expr._0) + "," + toString$2(expr._1) + ")";
    case /* Mul */2 :
        return "Mul(" + toString$2(expr._0) + "," + toString$2(expr._1) + ")";
    case /* Var */3 :
        return "Var(" + expr._0 + ")";
    case /* Let */4 :
        return "Let(" + expr._0 + "," + toString$2(expr._1) + "," + toString$2(expr._2) + ")";
    
  }
}

var Named = {
  toString: toString$2
};

function toString$3(instr) {
  if (typeof instr === "number") {
    if (instr === /* Add */0) {
      return "Add";
    } else {
      return "Mul";
    }
  }
  switch (instr.TAG | 0) {
    case /* Cst */0 :
        return "Cst(" + instr._0.toString() + ")";
    case /* Store */1 :
        return "Store(" + instr._0 + ")";
    case /* Load */2 :
        return "Load(" + instr._0 + ")";
    case /* Clear */3 :
        return "Clear(" + instr._0 + ")";
    
  }
}

function listToString$1(instrs) {
  var listTailToString = function (instrs) {
    return List.fold_left((function (s, inst) {
                  return s + ";" + toString$3(inst);
                }), "", instrs);
  };
  if (!instrs) {
    return "[]";
  }
  var rest = instrs.tl;
  var instr = instrs.hd;
  if (rest) {
    return "[" + toString$3(instr) + listTailToString(rest) + "]";
  } else {
    return "[" + toString$3(instr) + "]";
  }
}

function assoc(s, env) {
  var i = Belt_List.getAssoc(env, s, (function (a, b) {
          return a === b;
        }));
  if (i !== undefined) {
    return i;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Demo.res",
          142,
          16
        ],
        Error: new Error()
      };
}

function removeName(s, env) {
  return Belt_List.removeAssoc(env, s, (function (a, b) {
                return a === b;
              }));
}

function $$eval$1(_instrs, _stk, _env) {
  while(true) {
    var env = _env;
    var stk = _stk;
    var instrs = _instrs;
    if (!instrs) {
      return stk;
    }
    var i = instrs.hd;
    if (typeof i === "number") {
      if (i === /* Add */0) {
        if (stk) {
          var match = stk.tl;
          if (match) {
            _stk = {
              hd: stk.hd + match.hd | 0,
              tl: match.tl
            };
            _instrs = instrs.tl;
            continue ;
          }
          
        }
        
      } else if (stk) {
        var match$1 = stk.tl;
        if (match$1) {
          _stk = {
            hd: Math.imul(stk.hd, match$1.hd),
            tl: match$1.tl
          };
          _instrs = instrs.tl;
          continue ;
        }
        
      }
      
    } else {
      switch (i.TAG | 0) {
        case /* Cst */0 :
            _stk = {
              hd: i._0,
              tl: stk
            };
            _instrs = instrs.tl;
            continue ;
        case /* Store */1 :
            if (stk) {
              _env = {
                hd: [
                  i._0,
                  stk.hd
                ],
                tl: env
              };
              _stk = stk.tl;
              _instrs = instrs.tl;
              continue ;
            }
            break;
        case /* Load */2 :
            _stk = {
              hd: assoc(i._0, env),
              tl: stk
            };
            _instrs = instrs.tl;
            continue ;
        case /* Clear */3 :
            if (env) {
              if (i._0 !== env.hd[0]) {
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "Demo.res",
                        155,
                        8
                      ],
                      Error: new Error()
                    };
              }
              _env = env.tl;
              _instrs = instrs.tl;
              continue ;
            }
            break;
        
      }
    }
    console.log(listToString$1(instrs));
    console.log(stk);
    console.log(env);
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Demo.res",
            163,
            8
          ],
          Error: new Error()
        };
  };
}

function interpret$1(instrs) {
  var stk = $$eval$1(instrs, /* [] */0, /* [] */0);
  if (stk) {
    return stk.hd;
  }
  console.log("Empty stack");
  console.log(stk);
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Demo.res",
          174,
          8
        ],
        Error: new Error()
      };
}

var StackMachineWithName = {
  toString: toString$3,
  listToString: listToString$1,
  assoc: assoc,
  removeName: removeName,
  $$eval: $$eval$1,
  interpret: interpret$1
};

function mangled(s, d) {
  var len = s.length;
  return len.toString() + "_" + s + "_" + d.toString();
}

function depth(s, d) {
  var i = Belt_List.getAssoc(d, s, (function (a, b) {
          return a === b;
        }));
  if (i !== undefined) {
    return i;
  } else {
    return 0;
  }
}

function updatedDepthtable(d, s, v) {
  return Belt_List.setAssoc(d, s, v, (function (a, b) {
                return a === b;
              }));
}

function compHelper(expr, depthtable) {
  switch (expr.TAG | 0) {
    case /* Cst */0 :
        return {
                hd: {
                  TAG: /* Cst */0,
                  _0: expr._0
                },
                tl: /* [] */0
              };
    case /* Add */1 :
        return Belt_List.concatMany([
                    compHelper(expr._0, depthtable),
                    compHelper(expr._1, depthtable),
                    {
                      hd: /* Add */0,
                      tl: /* [] */0
                    }
                  ]);
    case /* Mul */2 :
        return Belt_List.concatMany([
                    compHelper(expr._0, depthtable),
                    compHelper(expr._1, depthtable),
                    {
                      hd: /* Mul */1,
                      tl: /* [] */0
                    }
                  ]);
    case /* Var */3 :
        var s = expr._0;
        return {
                hd: {
                  TAG: /* Load */2,
                  _0: mangled(s, depth(s, depthtable))
                },
                tl: /* [] */0
              };
    case /* Let */4 :
        var s$1 = expr._0;
        var cur = depth(s$1, depthtable);
        return Belt_List.concatMany([
                    compHelper(expr._1, depthtable),
                    {
                      hd: {
                        TAG: /* Store */1,
                        _0: mangled(s$1, cur + 1 | 0)
                      },
                      tl: /* [] */0
                    },
                    compHelper(expr._2, updatedDepthtable(depthtable, s$1, cur + 1 | 0)),
                    {
                      hd: {
                        TAG: /* Clear */3,
                        _0: mangled(s$1, cur + 1 | 0)
                      },
                      tl: /* [] */0
                    }
                  ]);
    
  }
}

function comp$1(expr) {
  return compHelper(expr, /* [] */0);
}

var NamedExprToStackWithName = {
  mangled: mangled,
  depth: depth,
  updatedDepthtable: updatedDepthtable,
  compHelper: compHelper,
  comp: comp$1
};

function transformer(state, instr) {
  var rev = state.outputRev;
  var d = state.depthtable;
  var sd = state.stkdepth;
  var getDiff = function (d, sd, s) {
    var i = Belt_List.getAssoc(d, s, (function (a, b) {
            return a === b;
          }));
    if (i !== undefined) {
      return sd - i | 0;
    }
    console.log("Invalid variable reference to \"" + s + "\"");
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Demo.res",
            250,
            10
          ],
          Error: new Error()
        };
  };
  var match;
  if (typeof instr === "number") {
    match = instr === /* Add */0 ? [
        {
          hd: /* Add */0,
          tl: /* [] */0
        },
        d,
        -1
      ] : [
        {
          hd: /* Mul */1,
          tl: /* [] */0
        },
        d,
        -1
      ];
  } else {
    switch (instr.TAG | 0) {
      case /* Cst */0 :
          match = [
            {
              hd: {
                TAG: /* Cst */0,
                _0: instr._0
              },
              tl: /* [] */0
            },
            d,
            1
          ];
          break;
      case /* Store */1 :
          match = [
            /* [] */0,
            Belt_List.setAssoc(d, instr._0, sd, (function (a, b) {
                    return a === b;
                  })),
            0
          ];
          break;
      case /* Load */2 :
          match = [
            {
              hd: {
                TAG: /* Var */1,
                _0: getDiff(d, sd, instr._0)
              },
              tl: /* [] */0
            },
            d,
            1
          ];
          break;
      case /* Clear */3 :
          match = [
            {
              hd: /* Pop */2,
              tl: {
                hd: /* Swap */3,
                tl: /* [] */0
              }
            },
            Belt_List.removeAssoc(d, instr._0, (function (a, b) {
                    return a === b;
                  })),
            -1
          ];
          break;
      
    }
  }
  return {
          outputRev: Belt_List.concat(match[0], rev),
          depthtable: match[1],
          stkdepth: sd + match[2] | 0
        };
}

function comp$2(instrs) {
  var finalState = Belt_List.reduce(instrs, {
        outputRev: /* [] */0,
        depthtable: /* [] */0,
        stkdepth: 0
      }, transformer);
  return Belt_List.reverse(finalState.outputRev);
}

var StackMachineWithNameToWithVariables = {
  transformer: transformer,
  comp: comp$2
};

var namedExprList = {
  hd: {
    TAG: /* Let */4,
    _0: "x",
    _1: {
      TAG: /* Cst */0,
      _0: 17
    },
    _2: {
      TAG: /* Add */1,
      _0: {
        TAG: /* Var */3,
        _0: "x"
      },
      _1: {
        TAG: /* Var */3,
        _0: "x"
      }
    }
  },
  tl: {
    hd: {
      TAG: /* Add */1,
      _0: {
        TAG: /* Cst */0,
        _0: 1
      },
      _1: {
        TAG: /* Let */4,
        _0: "x",
        _1: {
          TAG: /* Cst */0,
          _0: 2
        },
        _2: {
          TAG: /* Add */1,
          _0: {
            TAG: /* Var */3,
            _0: "x"
          },
          _1: {
            TAG: /* Cst */0,
            _0: 7
          }
        }
      }
    },
    tl: {
      hd: {
        TAG: /* Let */4,
        _0: "x",
        _1: {
          TAG: /* Let */4,
          _0: "x",
          _1: {
            TAG: /* Cst */0,
            _0: 1
          },
          _2: {
            TAG: /* Var */3,
            _0: "x"
          }
        },
        _2: {
          TAG: /* Let */4,
          _0: "x",
          _1: {
            TAG: /* Var */3,
            _0: "x"
          },
          _2: {
            TAG: /* Var */3,
            _0: "x"
          }
        }
      },
      tl: {
        hd: {
          TAG: /* Let */4,
          _0: "x",
          _1: {
            TAG: /* Cst */0,
            _0: 1
          },
          _2: {
            TAG: /* Cst */0,
            _0: 2
          }
        },
        tl: /* [] */0
      }
    }
  }
};

var namelessExprList = {
  hd: {
    TAG: /* Let */4,
    _0: {
      TAG: /* Cst */0,
      _0: 17
    },
    _1: {
      TAG: /* Add */1,
      _0: {
        TAG: /* Var */3,
        _0: 0
      },
      _1: {
        TAG: /* Var */3,
        _0: 1
      }
    }
  },
  tl: {
    hd: {
      TAG: /* Add */1,
      _0: {
        TAG: /* Cst */0,
        _0: 1
      },
      _1: {
        TAG: /* Let */4,
        _0: {
          TAG: /* Cst */0,
          _0: 2
        },
        _1: {
          TAG: /* Add */1,
          _0: {
            TAG: /* Var */3,
            _0: 0
          },
          _1: {
            TAG: /* Cst */0,
            _0: 7
          }
        }
      }
    },
    tl: {
      hd: {
        TAG: /* Let */4,
        _0: {
          TAG: /* Let */4,
          _0: {
            TAG: /* Cst */0,
            _0: 1
          },
          _1: {
            TAG: /* Var */3,
            _0: 0
          }
        },
        _1: {
          TAG: /* Let */4,
          _0: {
            TAG: /* Var */3,
            _0: 0
          },
          _1: {
            TAG: /* Var */3,
            _0: 1
          }
        }
      },
      tl: {
        hd: {
          TAG: /* Let */4,
          _0: {
            TAG: /* Cst */0,
            _0: 1
          },
          _1: {
            TAG: /* Cst */0,
            _0: 2
          }
        },
        tl: /* [] */0
      }
    }
  }
};

function task2Helper(expr) {
  console.log(toString$1(expr));
  var instrList = comp(expr);
  console.log("Compiled to " + listToString(instrList));
  console.log("\n");
  return instrList;
}

function task1Helper(instrList) {
  console.log(listToString(instrList));
  var val = interpret(instrList);
  console.log("Interpreted to " + val.toString());
  console.log("\n");
  return val;
}

function task3Helper(expr) {
  console.log(toString$2(expr));
  var namedInstrList = compHelper(expr, /* [] */0);
  console.log("Compiled to " + listToString$1(namedInstrList));
  var val = interpret$1(namedInstrList);
  console.log("Interpreted to " + val.toString());
  console.log("\n");
  return val;
}

function run(param) {
  console.log("Task 2 test:");
  var task2res = List.map(task2Helper, namelessExprList);
  console.log("\n");
  console.log("Task 1 test:");
  List.map(task1Helper, task2res);
  console.log("\n");
  console.log("Task 3 test:");
  List.map(task3Helper, namedExprList);
  console.log("\n");
}

var Test = {
  namedExprList: namedExprList,
  namelessExprList: namelessExprList,
  task2Helper: task2Helper,
  task1Helper: task1Helper,
  task3Helper: task3Helper,
  run: run
};

run(undefined);

exports.StackMachineWithVariables = StackMachineWithVariables;
exports.Nameless = Nameless;
exports.NamelessExprToStackMachineWithVariables = NamelessExprToStackMachineWithVariables;
exports.Named = Named;
exports.StackMachineWithName = StackMachineWithName;
exports.NamedExprToStackWithName = NamedExprToStackWithName;
exports.StackMachineWithNameToWithVariables = StackMachineWithNameToWithVariables;
exports.Test = Test;
/*  Not a pure module */
